<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api-documentation for
    <a
        
        href="https://nodemailer.com/"
        
    >nodemailer (v3.1.7)</a>
</h1>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer">module nodemailer</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.createTransport">
            function <span class="apidocSignatureSpan">nodemailer.</span>createTransport
            <span class="apidocSignatureSpan">(transporter, defaults)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.fetch">
            function <span class="apidocSignatureSpan">nodemailer.</span>fetch
            <span class="apidocSignatureSpan">(url, options)</span>
            </a>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodemailer.</span>base64</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodemailer.</span>mime_funcs</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodemailer.</span>qp</span>
            
        </li>
        
        <li>
            
            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodemailer.</span>shared</span>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer.base64">module nodemailer.base64</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.base64.Encoder">
            function <span class="apidocSignatureSpan">nodemailer.base64.</span>Encoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.base64.encode">
            function <span class="apidocSignatureSpan">nodemailer.base64.</span>encode
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.base64.wrap">
            function <span class="apidocSignatureSpan">nodemailer.base64.</span>wrap
            <span class="apidocSignatureSpan">(str, lineLength)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer.fetch">module nodemailer.fetch</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.fetch.fetch">
            function <span class="apidocSignatureSpan">nodemailer.</span>fetch
            <span class="apidocSignatureSpan">(url, options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.fetch.Cookies">
            function <span class="apidocSignatureSpan">nodemailer.fetch.</span>Cookies
            <span class="apidocSignatureSpan">(options)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer.mime_funcs">module nodemailer.mime_funcs</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.buildHeaderParam">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>buildHeaderParam
            <span class="apidocSignatureSpan">(key, data, maxLength)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.buildHeaderValue">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>buildHeaderValue
            <span class="apidocSignatureSpan">(structured)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.detectExtension">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>detectExtension
            <span class="apidocSignatureSpan">(mimeType)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.detectMimeType">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>detectMimeType
            <span class="apidocSignatureSpan">(extension)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.encodeURICharComponent">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeURICharComponent
            <span class="apidocSignatureSpan">(0)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.encodeWord">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeWord
            <span class="apidocSignatureSpan">(data, mimeWordEncoding, maxLength)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.encodeWords">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeWords
            <span class="apidocSignatureSpan">(value, mimeWordEncoding, maxLength)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.foldLines">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>foldLines
            <span class="apidocSignatureSpan">(str, lineLength, afterSpace)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.hasLongerLines">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>hasLongerLines
            <span class="apidocSignatureSpan">(str, lineLength)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.isPlainText">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>isPlainText
            <span class="apidocSignatureSpan">(value)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.parseHeaderValue">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>parseHeaderValue
            <span class="apidocSignatureSpan">(str)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.safeEncodeURIComponent">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>safeEncodeURIComponent
            <span class="apidocSignatureSpan">(str)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.mime_funcs.splitMimeEncodedString">
            function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>splitMimeEncodedString
            <span class="apidocSignatureSpan">(str, maxlen)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer.qp">module nodemailer.qp</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.qp.Encoder">
            function <span class="apidocSignatureSpan">nodemailer.qp.</span>Encoder
            <span class="apidocSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.qp.encode">
            function <span class="apidocSignatureSpan">nodemailer.qp.</span>encode
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.qp.wrap">
            function <span class="apidocSignatureSpan">nodemailer.qp.</span>wrap
            <span class="apidocSignatureSpan">(str, lineLength)</span>
            </a>
            
        </li>
        
    </ol></li>
    
    <li class="apidocModuleLi"><a href="#apidoc.module.nodemailer.shared">module nodemailer.shared</a><ol>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared._logFunc">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>_logFunc
            <span class="apidocSignatureSpan">(logger, level, defaults, data, message, ...args)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.assign">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>assign
            <span class="apidocSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.callbackPromise">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>callbackPromise
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.encodeXText">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>encodeXText
            <span class="apidocSignatureSpan">(!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.getLogger">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>getLogger
            <span class="apidocSignatureSpan">(options, defaults)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.parseConnectionUrl">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>parseConnectionUrl
            <span class="apidocSignatureSpan">(str, true)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="apidocElementLiA" href="#apidoc.element.nodemailer.shared.resolveContent">
            function <span class="apidocSignatureSpan">nodemailer.shared.</span>resolveContent
            <span class="apidocSignatureSpan">(data, key, callback)</span>
            </a>
            
        </li>
        
    </ol></li>
    
</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer" id="apidoc.module.nodemailer">module nodemailer</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.createTransport" id="apidoc.element.nodemailer.createTransport">
        function <span class="apidocSignatureSpan">nodemailer.</span>createTransport
        <span class="apidocSignatureSpan">(transporter, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTransport = function (transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;

    if (
        // provided transporter is a configuration object, not transporter plugin
        (typeof transporter === &#x27;object&#x27; &#x26;&#x26; typeof transporter.send !== &#x27;function&#x27;) ||
        // provided transporter looks like a connection url
        (typeof transporter === &#x27;string&#x27; &#x26;&#x26; /^(smtps?|direct):/i.test(transporter))
    ) {

        if ((urlConfig = typeof transporter === &#x27;string&#x27; ? transporter : transporter.url)) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }

        if (options.pool) {
            transporter = new SMTPPool(options);
        } else if (options.sendmail) {
            transporter = new SendmailTransport(options);
        } else if (options.streamTransport) {
            transporter = new StreamTransport(options);
        } else if (options.jsonTransport) {
            transporter = new JSONTransport(options);
        } else if (options.SES) {
            transporter = new SESTransport(options);
        } else {
            transporter = new SMTPTransport(options);
        }
    }

    mailer = new Mailer(transporter, options, defaults);

    return mailer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.fetch" id="apidoc.element.nodemailer.fetch">
        function <span class="apidocSignatureSpan">nodemailer.</span>fetch
        <span class="apidocSignatureSpan">(url, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (url, options) {
    return fetch(url, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    
    
    
    
    
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer.base64" id="apidoc.module.nodemailer.base64">module nodemailer.base64</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.base64.Encoder" id="apidoc.element.nodemailer.base64.Encoder">
        function <span class="apidocSignatureSpan">nodemailer.base64.</span>Encoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Encoder extends Transform {
    constructor(options) {
        super();
        // init Transform
        this.options = options || {};

        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }

        this._curLine = &#x27;&#x27;;
        this._remainingBytes = false;

        this.inputBytes = 0;
        this.outputBytes = 0;
    }

    _transform(chunk, encoding, done) {
        let b64;

        if (encoding !== &#x27;buffer&#x27;) {
            chunk = new Buffer(chunk, encoding);
        }

        if (!chunk || !chunk.length) {
            return done();
        }

        this.inputBytes += chunk.length;

        if (this._remainingBytes &#x26;&#x26; this._remainingBytes.length) {
            chunk = Buffer.concat([this._remainingBytes, chunk]);
            this._remainingBytes = false;
        }

        if (chunk.length % 3) {
            this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
            chunk = chunk.slice(0, chunk.length - chunk.length % 3);
        } else {
            this._remainingBytes = false;
        }

        b64 = this._curLine + encode(chunk);

        if (this.options.lineLength) {
            b64 = wrap(b64, this.options.lineLength);
            b64 = b64.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) =&#x3e; {
                this._curLine = lastLine;
                return lineBreak;
            });
        }

        if (b64) {
            this.outputBytes += b64.length;
            this.push(b64);
        }

        done();
    }

    _flush(done) {
        if (this._remainingBytes &#x26;&#x26; this._remainingBytes.length) {
            this._curLine += encode(this._remainingBytes);
        }

        if (this._curLine) {
            this._curLine = wrap(this._curLine, this.options.lineLength);
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, &#x27;ascii&#x27;);
            this._curLine = &#x27;&#x27;;
        }
        done();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.base64.encode" id="apidoc.element.nodemailer.base64.encode">
        function <span class="apidocSignatureSpan">nodemailer.base64.</span>encode
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(buffer) {
    if (typeof buffer === &#x27;string&#x27;) {
        buffer = new Buffer(buffer, &#x27;utf-8&#x27;);
    }

    return buffer.toString(&#x27;base64&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.base64.wrap" id="apidoc.element.nodemailer.base64.wrap">
        function <span class="apidocSignatureSpan">nodemailer.base64.</span>wrap
        <span class="apidocSignatureSpan">(str, lineLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(str, lineLength) {
    str = (str || &#x27;&#x27;).toString();
    lineLength = lineLength || 76;

    if (str.length &#x3c;= lineLength) {
        return str;
    }

    let result = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos &#x3c; str.length) {
        let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(&#x27;.{&#x27; + lineLength + &#x27;}&#x27;, &#x27;g&#x27;), &#x27;$&#x26;\r\n&#x27;).trim();
        result.push(wrappedLines);
        pos += chunkLength;
    }

    return result.join(&#x27;\r\n&#x27;).trim();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer.fetch" id="apidoc.module.nodemailer.fetch">module nodemailer.fetch</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.fetch.fetch" id="apidoc.element.nodemailer.fetch.fetch">
        function <span class="apidocSignatureSpan">nodemailer.</span>fetch
        <span class="apidocSignatureSpan">(url, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fetch = function (url, options) {
    return fetch(url, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.fetch.Cookies" id="apidoc.element.nodemailer.fetch.Cookies">
        function <span class="apidocSignatureSpan">nodemailer.fetch.</span>Cookies
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Cookies {
    constructor(options) {
        this.options = options || {};
        this.cookies = [];
    }

<span class="apidocCodeCommentSpan">    /**
     * Stores a cookie string to the cookie storage
     *
     * @param {String} cookieStr Value from the &#x27;Set-Cookie:&#x27; header
     * @param {String} url Current URL
     */
</span>    set(cookieStr, url) {
        let urlparts = urllib.parse(url || &#x27;&#x27;);
        let cookie = this.parse(cookieStr);
        let domain;

        if (cookie.domain) {
            domain = cookie.domain.replace(/^\./, &#x27;&#x27;);

            // do not allow cross origin cookies
            if (
                // can&#x27;t be valid if the requested domain is shorter than current hostname
                urlparts.hostname.length &#x3c; domain.length ||

                // prefix domains with dot to be sure that partial matches are not used
                (&#x27;.&#x27; + urlparts.hostname).substr(-domain.length + 1) !== (&#x27;.&#x27; + domain)) {
                cookie.domain = urlparts.hostname;
            }
        } else {
            cookie.domain = urlparts.hostname;
        }

        if (!cookie.path) {
            cookie.path = this.getPath(urlparts.pathname);
        }

        // if no expire date, then use sessionTimeout value
        if (!cookie.expires) {
            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) *\
 1000);
        }

        return this.add(cookie);
    }

    /**
     * Returns cookie string for the &#x27;Cookie:&#x27; header.
     *
     * @param {String} url URL to check for
     * @returns {String} Cookie header or empty string if no matches were found
     */
    get(url) {
        return this.list(url).map(cookie =&#x3e;
            cookie.name + &#x27;=&#x27; + cookie.value).join(&#x27;; &#x27;);
    }

    /**
     * Lists all valied cookie objects for the specified URL
     *
     * @param {String} url URL to check for
     * @returns {Array} An array of cookie objects
     */
    list(url) {
        let result = [];
        let i;
        let cookie;

        for (i = this.cookies.length - 1; i &#x3e;= 0; i--) {
            cookie = this.cookies[i];

            if (this.isExpired(cookie)) {
                this.cookies.splice(i, i);
                continue;
            }

            if (this.match(cookie, url)) {
                result.unshift(cookie);
            }
        }

        return result;
    }

    /**
     * Parses cookie string from the &#x27;Set-Cookie:&#x27; header
     *
     * @param {String} cookieStr String from the &#x27;Set-Cookie:&#x27; header
     * @returns {Object} Cookie object
     */
    parse(cookieStr) {
        let cookie = {};

        (cookieStr || &#x27;&#x27;).toString().split(&#x27;;&#x27;).forEach(cookiePart =&#x3e; {
            let valueParts = cookiePart.split(&#x27;=&#x27;);
            let key = valueParts.shift().trim().toLowerCase();
            let value = valueParts.join(&#x27;=&#x27;).trim();
            let domain;

            if (!key) {
                // skip empty parts
                return;
            }

            switch (key) {

                case &#x27;expires&#x27;:
                    value = new Date(value);
                    // ignore date if can not parse it
                    if (value.toString() !== &#x27;Invalid Date&#x27;) {
                        cookie.expires = value;
                    }
                    break;

                case &#x27;path&#x27;:
                    cookie.path = value;
                    break;

                case &#x27;domain&#x27;:
                    domain = value.toLowerCase();
                    if (domain.length &#x26;&#x26; domain.charAt(0) !== &#x27;.&#x27;) {
                        domain = &#x27;.&#x27; + domain; // ensure preceeding dot for user set domains
                    }
                    cookie.domain = domain;
                    break;

                case &#x27;max-age&#x27;:
                    cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                    break;

                case &#x27;secure&#x27;:
                    cookie.secure = true;
                    break;

                case &#x27;httponly&#x27;:
                    cookie.httponly = true;
                    break; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer.mime_funcs" id="apidoc.module.nodemailer.mime_funcs">module nodemailer.mime_funcs</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.buildHeaderParam" id="apidoc.element.nodemailer.mime_funcs.buildHeaderParam">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>buildHeaderParam
        <span class="apidocSignatureSpan">(key, data, maxLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildHeaderParam(key, data, maxLength) {
    let list = [];
    let encodedStr = typeof data === &#x27;string&#x27; ? data : (data || &#x27;&#x27;).toString();
    let encodedStrArr;
    let chr, ord;
    let line;
    let startPos = 0;
    let i, len;

    maxLength = maxLength || 50;

    // process ascii only text
    if (this.isPlainText(data)) {

        // check if conversion is even needed
        if (encodedStr.length &#x3c;= maxLength) {
            return [{
                key,
                value: encodedStr
            }];
        }

        encodedStr = encodedStr.replace(new RegExp(&#x27;.{&#x27; + maxLength + &#x27;}&#x27;, &#x27;g&#x27;), str =&#x3e; {
            list.push({
                line: str
            });
            return &#x27;&#x27;;
        });

        if (encodedStr) {
            list.push({
                line: encodedStr
            });
        }

    } else {

        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
            // string containts surrogate pairs, so normalize it to an array of bytes
            encodedStrArr = [];
            for (i = 0, len = encodedStr.length; i &#x3c; len; i++) {
                chr = encodedStr.charAt(i);
                ord = chr.charCodeAt(0);
                if (ord &#x3e;= 0xD800 &#x26;&#x26; ord &#x3c;= 0xDBFF &#x26;&#x26; i &#x3c; len - 1) {
                    chr += encodedStr.charAt(i + 1);
                    encodedStrArr.push(chr);
                    i++;
                } else {
                    encodedStrArr.push(chr);
                }
            }
            encodedStr = encodedStrArr;
        }

        // first line includes the charset and language info and needs to be encoded
        // even if it does not contain any unicode characters
        line = &#x27;utf-8\&#x27;\&#x27;&#x27;;
        let encoded = true;
        startPos = 0;

        // process text with unicode or special chars
        for (i = 0, len = encodedStr.length; i &#x3c; len; i++) {

            chr = encodedStr[i];

            if (encoded) {
                chr = this.safeEncodeURIComponent(chr);
            } else {
                // try to urlencode current char
                chr = chr === &#x27; &#x27; ? chr : this.safeEncodeURIComponent(chr);
                // By default it is not required to encode a line, the need
                // only appears when the string contains unicode or special chars
                // in this case we start processing the line over and encode all chars
                if (chr !== encodedStr[i]) {
                    // Check if it is even possible to add the encoded char to the line
                    // If not, there is no reason to use this line, just push it to the list
                    // and start a new line with the char that needs encoding
                    if ((this.safeEncodeURIComponent(line) + chr).length &#x3e;= maxLength) {
                        list.push({
                            line,
                            encoded
                        });
                        line = &#x27;&#x27;;
                        startPos = i - 1;
                    } else {
                        encoded = true;
                        i = startPos;
                        line = &#x27;&#x27;;
                        continue;
                    }
                }
            }

            // if the line is already too long, push it to the list and start a new one
            if ((line + chr).length &#x3e;= maxLength) {
                list.push({
                    line,
                    encoded
                });
                line = chr = encodedStr[i] === &#x27; &#x27; ? &#x27; &#x27; : this.safeEncodeURIComponent(encodedStr[i]);
                if (chr === encodedStr[i]) {
                    encoded = false;
                    startPos = i - 1;
                } else {
                    encoded = true;
                }
            } else {
                line += chr;
            }
        }

        if (line) {
            list.push({
                line,
                encoded
            });
        }
    }

    return list.map((item, i) =&#x3e; ({
        // encoded lines: {name}*{part}*
        // unencoded lines: {name}*{part}
        // if any line needs to be encode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.buildHeaderValue" id="apidoc.element.nodemailer.mime_funcs.buildHeaderValue">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>buildHeaderValue
        <span class="apidocSignatureSpan">(structured)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildHeaderValue(structured) {
    let paramsArray = [];

    Object.keys(structured.params || {}).forEach(param =&#x3e; {
        // filename might include unicode characters so it is a special case
        // other values probably do not
        let value = structured.params[param];
        if (!this.isPlainText(value) || value.length &#x3e;= 75) {
            this.buildHeaderParam(param, value, 50).forEach(encodedParam =&#x3e; {
                if (!/[\s&#x22;\\;:\/=\(\),&#x3c;&#x3e;@\[\]\?]|^[\-&#x27;]|&#x27;$/.test(encodedParam.value) || encodedParam.key.substr(-1) === &#x27;*&#x27;) {
                    paramsArray.push(encodedParam.key + &#x27;=&#x27; + encodedParam.value);
                } else {
                    paramsArray.push(encodedParam.key + &#x27;=&#x27; + JSON.stringify(encodedParam.value));
                }
            });
        } else if (/[\s&#x27;&#x22;\\;:\/=\(\),&#x3c;&#x3e;@\[\]\?]|^\-/.test(value)) {
            paramsArray.push(param + &#x27;=&#x27; + JSON.stringify(value));
        } else {
            paramsArray.push(param + &#x27;=&#x27; + value);
        }
    });

    return structured.value + (paramsArray.length ? &#x27;; &#x27; + paramsArray.join(&#x27;; &#x27;) : &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.detectExtension" id="apidoc.element.nodemailer.mime_funcs.detectExtension">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>detectExtension
        <span class="apidocSignatureSpan">(mimeType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mimeType =&#x3e; mimeTypes.detectExtension(mimeType)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.detectMimeType" id="apidoc.element.nodemailer.mime_funcs.detectMimeType">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>detectMimeType
        <span class="apidocSignatureSpan">(extension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extension =&#x3e; mimeTypes.detectMimeType(extension)</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.encodeURICharComponent" id="apidoc.element.nodemailer.mime_funcs.encodeURICharComponent">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeURICharComponent
        <span class="apidocSignatureSpan">(0)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chr =&#x3e; {
    let res = &#x27;&#x27;;
    let ord = chr.charCodeAt(0).toString(16).toUpperCase();

    if (ord.length % 2) {
        ord = &#x27;0&#x27; + ord;
    }

    if (ord.length &#x3e; 2) {
        for (let i = 0, len = ord.length / 2; i &#x3c; len; i++) {
            res += &#x27;%&#x27; + ord.substr(i, 2);
        }
    } else {
        res += &#x27;%&#x27; + ord;
    }

    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.encodeWord" id="apidoc.element.nodemailer.mime_funcs.encodeWord">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeWord
        <span class="apidocSignatureSpan">(data, mimeWordEncoding, maxLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeWord(data, mimeWordEncoding, maxLength) {
    mimeWordEncoding = (mimeWordEncoding || &#x27;Q&#x27;).toString().toUpperCase().trim().charAt(0);
    maxLength = maxLength || 0;

    let encodedStr;
    let toCharset = &#x27;UTF-8&#x27;;

    if (maxLength &#x26;&#x26; maxLength &#x3e; 7 + toCharset.length) {
        maxLength -= (7 + toCharset.length);
    }

    if (mimeWordEncoding === &#x27;Q&#x27;) {
        // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
        encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-\/=]/ig, chr =&#x3e; {
            let ord = chr.charCodeAt(0).toString(16).toUpperCase();
            if (chr === &#x27; &#x27;) {
                return &#x27;_&#x27;;
            } else {
                return &#x27;=&#x27; + (ord.length === 1 ? &#x27;0&#x27; + ord : ord);
            }
        });
    } else if (mimeWordEncoding === &#x27;B&#x27;) {
        encodedStr = typeof data === &#x27;string&#x27; ? data : base64.encode(data);
        maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
    }

    if (maxLength &#x26;&#x26; (mimeWordEncoding !== &#x27;B&#x27; ? encodedStr : base64.encode(data)).length &#x3e; maxLength) {
        if (mimeWordEncoding === &#x27;Q&#x27;) {
            encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join(&#x27;?= =?&#x27; + toCharset + &#x27;?&#x27; + mimeWordEncoding + \
&#x27;?&#x27;);
        } else {
            // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode se\
quences
            let parts = [];
            let lpart = &#x27;&#x27;;
            for (let i = 0, len = encodedStr.length; i &#x3c; len; i++) {
                let chr = encodedStr.charAt(i);
                // check if we can add this character to the existing string
                // without breaking byte length limit
                if (Buffer.byteLength(lpart + chr) &#x3c;= maxLength || i === 0) {
                    lpart += chr;
                } else {
                    // we hit the length limit, so push the existing string and start over
                    parts.push(base64.encode(lpart));
                    lpart = chr;
                }
            }
            if (lpart) {
                parts.push(base64.encode(lpart));
            }

            if (parts.length &#x3e; 1) {
                encodedStr = parts.join(&#x27;?= =?&#x27; + toCharset + &#x27;?&#x27; + mimeWordEncoding + &#x27;?&#x27;);
            } else {
                encodedStr = parts.join(&#x27;&#x27;);
            }
        }
    } else if (mimeWordEncoding === &#x27;B&#x27;) {
        encodedStr = base64.encode(data);
    }

    return &#x27;=?&#x27; + toCharset + &#x27;?&#x27; + mimeWordEncoding + &#x27;?&#x27; + encodedStr + (encodedStr.substr(-2) === &#x27;?=&#x27; ? &#x27;&#x27; : &#x27;?=&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.encodeWords" id="apidoc.element.nodemailer.mime_funcs.encodeWords">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>encodeWords
        <span class="apidocSignatureSpan">(value, mimeWordEncoding, maxLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encodeWords(value, mimeWordEncoding, maxLength) {
    maxLength = maxLength || 0;

    let encodedValue;

    // find first word with a non-printable ascii in it
    let firstMatch = value.match(/(?:^|\s)([^\s]*[\u0080-\uFFFF])/);
    if (!firstMatch) {
        return value;
    }

    // find the last word with a non-printable ascii in it
    let lastMatch = value.match(/([\u0080-\uFFFF][^\s]*)[^\u0080-\uFFFF]*$/);
    if (!lastMatch) {
        // should not happen
        return value;
    }

    let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
        index: 0
    }).index;
    let endIndex = lastMatch.index + (lastMatch[1] || &#x27;&#x27;).length;

    encodedValue =
        (startIndex ? value.substr(0, startIndex) : &#x27;&#x27;) + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncodin\
g || &#x27;Q&#x27;, maxLength) +
        (endIndex &#x3c; value.length ? value.substr(endIndex) : &#x27;&#x27;);

    return encodedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.foldLines" id="apidoc.element.nodemailer.mime_funcs.foldLines">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>foldLines
        <span class="apidocSignatureSpan">(str, lineLength, afterSpace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">foldLines(str, lineLength, afterSpace) {
    str = (str || &#x27;&#x27;).toString();
    lineLength = lineLength || 76;

    let pos = 0,
        len = str.length,
        result = &#x27;&#x27;,
        line, match;

    while (pos &#x3c; len) {
        line = str.substr(pos, lineLength);
        if (line.length &#x3c; lineLength) {
            result += line;
            break;
        }
        if ((match = line.match(/^[^\n\r]*(\r?\n|\r)/))) {
            line = match[0];
            result += line;
            pos += line.length;
            continue;
        } else if ((match = line.match(/(\s+)[^\s]*$/)) &#x26;&#x26; match[0].length - (afterSpace ? (match[1] || &#x27;&#x27;).length : 0) &#x3c; line.l\
ength) {
            line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || &#x27;&#x27;).length : 0)));
        } else if ((match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/))) {
            line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || &#x27;&#x27;).length : 0));
        }

        result += line;
        pos += line.length;
        if (pos &#x3c; len) {
            result += &#x27;\r\n&#x27;;
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.hasLongerLines" id="apidoc.element.nodemailer.mime_funcs.hasLongerLines">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>hasLongerLines
        <span class="apidocSignatureSpan">(str, lineLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasLongerLines(str, lineLength) {
    if (str.length &#x3e; 128 * 1024) {
        // do not test strings longer than 128kB
        return true;
    }
    return new RegExp(&#x27;^.{&#x27; + (lineLength + 1) + &#x27;,}&#x27;, &#x27;m&#x27;).test(str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.isPlainText" id="apidoc.element.nodemailer.mime_funcs.isPlainText">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>isPlainText
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPlainText(value) {
    if (typeof value !== &#x27;string&#x27; || /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/.test(value)) {
        return false;
    } else {
        return true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.parseHeaderValue" id="apidoc.element.nodemailer.mime_funcs.parseHeaderValue">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>parseHeaderValue
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseHeaderValue(str) {
    let response = {
        value: false,
        params: {}
    };
    let key = false;
    let value = &#x27;&#x27;;
    let type = &#x27;value&#x27;;
    let quote = false;
    let escaped = false;
    let chr;

    for (let i = 0, len = str.length; i &#x3c; len; i++) {
        chr = str.charAt(i);
        if (type === &#x27;key&#x27;) {
            if (chr === &#x27;=&#x27;) {
                key = value.trim().toLowerCase();
                type = &#x27;value&#x27;;
                value = &#x27;&#x27;;
                continue;
            }
            value += chr;
        } else {
            if (escaped) {
                value += chr;
            } else if (chr === &#x27;\\&#x27;) {
                escaped = true;
                continue;
            } else if (quote &#x26;&#x26; chr === quote) {
                quote = false;
            } else if (!quote &#x26;&#x26; chr === &#x27;&#x22;&#x27;) {
                quote = chr;
            } else if (!quote &#x26;&#x26; chr === &#x27;;&#x27;) {
                if (key === false) {
                    response.value = value.trim();
                } else {
                    response.params[key] = value.trim();
                }
                type = &#x27;key&#x27;;
                value = &#x27;&#x27;;
            } else {
                value += chr;
            }
            escaped = false;

        }
    }

    if (type === &#x27;value&#x27;) {
        if (key === false) {
            response.value = value.trim();
        } else {
            response.params[key] = value.trim();
        }
    } else if (value.trim()) {
        response.params[value.trim().toLowerCase()] = &#x27;&#x27;;
    }

    // handle parameter value continuations
    // https://tools.ietf.org/html/rfc2231#section-3

    // preprocess values
    Object.keys(response.params).forEach(key =&#x3e; {
        let actualKey, nr, match, value;
        if ((match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/))) {
            actualKey = key.substr(0, match.index);
            nr = Number(match[2] || match[3]) || 0;

            if (!response.params[actualKey] || typeof response.params[actualKey] !== &#x27;object&#x27;) {
                response.params[actualKey] = {
                    charset: false,
                    values: []
                };
            }

            value = response.params[key];

            if (nr === 0 &#x26;&#x26; match[0].substr(-1) === &#x27;*&#x27; &#x26;&#x26; (match = value.match(/^([^&#x27;]*)&#x27;[^&#x27;]*&#x27;(.*)$/))) {
                response.params[actualKey].charset = match[1] || &#x27;iso-8859-1&#x27;;
                value = match[2];
            }

            response.params[actualKey].values[nr] = value;

            // remove the old reference
            delete response.params[key];
        }
    });

    // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
    Object.keys(response.params).forEach(key =&#x3e; {
        let value;
        if (response.params[key] &#x26;&#x26; Array.isArray(response.params[key].values)) {
            value = response.params[key].values.map(val =&#x3e; val || &#x27;&#x27;).join(&#x27;&#x27;);

            if (response.params[key].charset) {
                // convert &#x22;%AB&#x22; to &#x22;=?charset?Q?=AB?=&#x22;
                response.params[key] = &#x27;=?&#x27; +
                    response.params[key].charset +
                    &#x27;?Q?&#x27; +
                    value.
                // fix invalidly encoded chars
                replace(/[=\?_\s]/g,
                    s =&#x3e; {
                        let c = s.charCodeAt(0).toString(16);
                        if (s === &#x27; &#x27;) {
                            return &#x27;_&#x27;;
                        } else {
                            return &#x27;%&#x27; + (c.length &#x3c; 2 ? &#x27;0&#x27; : &#x27;&#x27;) + c;
                        }
                    }
                ).
                // change from urlencoding to percent encoding
                replace(/%/g, &#x27;=&#x27;) +
                    &#x27;?=&#x27;;
            } else {
                response.params[key] = value;
            }
        }
    });

    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.safeEncodeURIComponent" id="apidoc.element.nodemailer.mime_funcs.safeEncodeURIComponent">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>safeEncodeURIComponent
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">safeEncodeURIComponent(str) {
    str = (str || &#x27;&#x27;).toString();

    try {
        // might throw if we try to encode invalid sequences, eg. partial emoji
        str = encodeURIComponent(str);
    } catch (E) {
        // should never run
        return str.replace(/[^\x00-\x1F *&#x27;()&#x3c;&#x3e;@,;:\\&#x22;\[\]?=\u007F-\uFFFF]+/g, &#x27;&#x27;);
    }

    // ensure chars that are not handled by encodeURICompent are converted as well
    return str.replace(/[\x00-\x1F *&#x27;()&#x3c;&#x3e;@,;:\\&#x22;\[\]?=\u007F-\uFFFF]/g, chr =&#x3e; this.encodeURICharComponent(chr));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.mime_funcs.splitMimeEncodedString" id="apidoc.element.nodemailer.mime_funcs.splitMimeEncodedString">
        function <span class="apidocSignatureSpan">nodemailer.mime_funcs.</span>splitMimeEncodedString
        <span class="apidocSignatureSpan">(str, maxlen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(str, maxlen) =&#x3e; {
    let curLine, match, chr, done,
        lines = [];

    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
    maxlen = Math.max(maxlen || 0, 12);

    while (str.length) {
        curLine = str.substr(0, maxlen);

        // move incomplete escaped char back to main
        if ((match = curLine.match(/\=[0-9A-F]?$/i))) {
            curLine = curLine.substr(0, match.index);
        }

        done = false;
        while (!done) {
            done = true;
            // check if not middle of a unicode char sequence
            if ((match = str.substr(curLine.length).match(/^\=([0-9A-F]{2})/i))) {
                chr = parseInt(match[1], 16);
                // invalid sequence, move one char back anc recheck
                if (chr &#x3c; 0xC2 &#x26;&#x26; chr &#x3e; 0x7F) {
                    curLine = curLine.substr(0, curLine.length - 3);
                    done = false;
                }
            }
        }

        if (curLine.length) {
            lines.push(curLine);
        }
        str = str.substr(curLine.length);
    }

    return lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer.qp" id="apidoc.module.nodemailer.qp">module nodemailer.qp</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.qp.Encoder" id="apidoc.element.nodemailer.qp.Encoder">
        function <span class="apidocSignatureSpan">nodemailer.qp.</span>Encoder
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Encoder extends Transform {
    constructor(options) {
        super();

        // init Transform
        this.options = options || {};

        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }

        this._curLine = &#x27;&#x27;;

        this.inputBytes = 0;
        this.outputBytes = 0;
    }

    _transform(chunk, encoding, done) {
        let qp;

        if (encoding !== &#x27;buffer&#x27;) {
            chunk = new Buffer(chunk, encoding);
        }

        if (!chunk || !chunk.length) {
            return done();
        }

        this.inputBytes += chunk.length;

        if (this.options.lineLength) {
            qp = this._curLine + encode(chunk);
            qp = wrap(qp, this.options.lineLength);
            qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) =&#x3e; {
                this._curLine = lastLine;
                return lineBreak;
            });

            if (qp) {
                this.outputBytes += qp.length;
                this.push(qp);
            }

        } else {
            qp = encode(chunk);
            this.outputBytes += qp.length;
            this.push(qp, &#x27;ascii&#x27;);
        }

        done();
    }

    _flush(done) {
        if (this._curLine) {
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, &#x27;ascii&#x27;);
        }
        done();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.qp.encode" id="apidoc.element.nodemailer.qp.encode">
        function <span class="apidocSignatureSpan">nodemailer.qp.</span>encode
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(buffer) {
    if (typeof buffer === &#x27;string&#x27;) {
        buffer = new Buffer(buffer, &#x27;utf-8&#x27;);
    }

    // usable characters that do not need encoding
    let ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [0x09], // &#x3c;TAB&#x3e;
        [0x0A], // &#x3c;LF&#x3e;
        [0x0D], // &#x3c;CR&#x3e;
        [0x20, 0x3C], // &#x3c;SP&#x3e;!&#x22;#$%&#x26;&#x27;()*+,-./0123456789:;
        [0x3E, 0x7E] // &#x3e;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    let result = &#x27;&#x27;;
    let ord;

    for (let i = 0, len = buffer.length; i &#x3c; len; i++) {
        ord = buffer[i];
        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line
        if (checkRanges(ord, ranges) &#x26;&#x26; !((ord === 0x20 || ord === 0x09) &#x26;&#x26; (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i\
 + 1] === 0x0d))) {
            result += String.fromCharCode(ord);
            continue;
        }
        result += &#x27;=&#x27; + (ord &#x3c; 0x10 ? &#x27;0&#x27; : &#x27;&#x27;) + ord.toString(16).toUpperCase();
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.qp.wrap" id="apidoc.element.nodemailer.qp.wrap">
        function <span class="apidocSignatureSpan">nodemailer.qp.</span>wrap
        <span class="apidocSignatureSpan">(str, lineLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(str, lineLength) {
    str = (str || &#x27;&#x27;).toString();
    lineLength = lineLength || 76;

    if (str.length &#x3c;= lineLength) {
        return str;
    }

    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result = &#x27;&#x27;;

    // insert soft linebreaks where needed
    while (pos &#x3c; len) {
        line = str.substr(pos, lineLength);
        if ((match = line.match(/\r\n/))) {
            line = line.substr(0, match.index + match[0].length);
            result += line;
            pos += line.length;
            continue;
        }

        if (line.substr(-1) === &#x27;\n&#x27;) {
            // nothing to change here
            result += line;
            pos += line.length;
            continue;
        } else if ((match = line.substr(-lineMargin).match(/\n.*?$/))) {
            // truncate to nearest line break
            line = line.substr(0, line.length - (match[0].length - 1));
            result += line;
            pos += line.length;
            continue;
        } else if (line.length &#x3e; lineLength - lineMargin &#x26;&#x26; (match = line.substr(-lineMargin).match(/[ \t\.,!\?][^ \t\.,!\?]*$/)\
)) {
            // truncate to nearest space
            line = line.substr(0, line.length - (match[0].length - 1));
        } else if (line.match(/\=[\da-f]{0,2}$/i)) {

            // push incomplete encoding sequences to the next line
            if ((match = line.match(/\=[\da-f]{0,1}$/i))) {
                line = line.substr(0, line.length - match[0].length);
            }

            // ensure that utf-8 sequences are not split
            while (line.length &#x3e; 3 &#x26;&#x26; line.length &#x3c; len - pos &#x26;&#x26; !line.match(/^(?:=[\da-f]{2}){1,4}$/i) &#x26;&#x26; (match = line.match(/\=[\da-f]{2}$/ig))) {
                code = parseInt(match[0].substr(1, 2), 16);
                if (code &#x3c; 128) {
                    break;
                }

                line = line.substr(0, line.length - 3);

                if (code &#x3e;= 0xC0) {
                    break;
                }
            }
        }

        if (pos + line.length &#x3c; len &#x26;&#x26; line.substr(-1) !== &#x27;\n&#x27;) {
            if (line.length === lineLength &#x26;&#x26; line.match(/\=[\da-f]{2}$/i)) {
                line = line.substr(0, line.length - 3);
            } else if (line.length === lineLength) {
                line = line.substr(0, line.length - 1);
            }
            pos += line.length;
            line += &#x27;=\r\n&#x27;;
        } else {
            pos += line.length;
        }

        result += line;
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodemailer.shared" id="apidoc.module.nodemailer.shared">module nodemailer.shared</a></h1>
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared._logFunc" id="apidoc.element.nodemailer.shared._logFunc">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>_logFunc
        <span class="apidocSignatureSpan">(logger, level, defaults, data, message, ...args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(logger, level, defaults, data, message, ...args) =&#x3e; {
    let entry = {};

    Object.keys(defaults || {}).forEach(key =&#x3e; {
        if (key !== &#x27;level&#x27;) {
            entry[key] = defaults[key];
        }
    });

    Object.keys(data || {}).forEach(key =&#x3e; {
        if (key !== &#x27;level&#x27;) {
            entry[key] = data[key];
        }
    });

    logger[level](entry, message, ...args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.assign" id="apidoc.element.nodemailer.shared.assign">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>assign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assign = function () {
    let args = Array.from(arguments);
    let target = args.shift() || {};

    args.forEach(source =&#x3e; {
        Object.keys(source || {}).forEach(key =&#x3e; {
            if ([&#x27;tls&#x27;, &#x27;auth&#x27;].includes(key) &#x26;&#x26; source[key] &#x26;&#x26; typeof source[key] === &#x27;object&#x27;) {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // ensure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach(subKey =&#x3e; {
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.callbackPromise" id="apidoc.element.nodemailer.shared.callbackPromise">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>callbackPromise
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(resolve, reject) =&#x3e; function () {
    let args = Array.from(arguments);
    let err = args.shift();
    if (err) {
        reject(err);
    } else {
        resolve(...args);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.encodeXText" id="apidoc.element.nodemailer.shared.encodeXText">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>encodeXText
        <span class="apidocSignatureSpan">(!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">str =&#x3e; {
    // ! 0x21
    // + 0x2B
    // = 0x3D
    // ~ 0x7E
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
    }
    let buf = Buffer.from(str);
    let result = &#x27;&#x27;;
    for (let i = 0, len = buf.length; i &#x3c; len; i++) {
        let c = buf[i];
        if (c &#x3c; 0x21 || c &#x3e; 0x7e || c === 0x2b || c === 0x3d) {
            result += &#x27;+&#x27; + (c &#x3c; 0x10 ? &#x27;0&#x27; : &#x27;&#x27;) + c.toString(16).toUpperCase();
        } else {
            result += String.fromCharCode(c);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.getLogger" id="apidoc.element.nodemailer.shared.getLogger">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>getLogger
        <span class="apidocSignatureSpan">(options, defaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(options, defaults) =&#x3e; {
    options = options || {};

    let response = {};
    let levels = [&#x27;trace&#x27;, &#x27;debug&#x27;, &#x27;info&#x27;, &#x27;warn&#x27;, &#x27;error&#x27;, &#x27;fatal&#x27;];

    if (!options.logger) {
        // use vanity logger
        levels.forEach(level =&#x3e; {
            response[level] = () =&#x3e; false;
        });
        return response;
    }

    let logger = options.logger;

    if (options.logger === true) {
        // create console logger
        logger = createDefaultLogger(levels);
    }

    levels.forEach(level =&#x3e; {
        response[level] = (data, message, ...args) =&#x3e; {
            module.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
    });

    return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.parseConnectionUrl" id="apidoc.element.nodemailer.shared.parseConnectionUrl">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>parseConnectionUrl
        <span class="apidocSignatureSpan">(str, true)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">str =&#x3e; {
    str = str || &#x27;&#x27;;
    let options = {};

    [urllib.parse(str, true)].forEach(url =&#x3e; {
        let auth;

        switch (url.protocol) {
            case &#x27;smtp:&#x27;:
                options.secure = false;
                break;
            case &#x27;smtps:&#x27;:
                options.secure = true;
                break;
            case &#x27;direct:&#x27;:
                options.direct = true;
                break;
        }

        if (!isNaN(url.port) &#x26;&#x26; Number(url.port)) {
            options.port = Number(url.port);
        }

        if (url.hostname) {
            options.host = url.hostname;
        }

        if (url.auth) {
            auth = url.auth.split(&#x27;:&#x27;);

            if (!options.auth) {
                options.auth = {};
            }

            options.auth.user = auth.shift();
            options.auth.pass = auth.join(&#x27;:&#x27;);
        }

        Object.keys(url.query || {}).forEach(key =&#x3e; {
            let obj = options;
            let lKey = key;
            let value = url.query[key];

            if (!isNaN(value)) {
                value = Number(value);
            }

            switch (value) {
                case &#x27;true&#x27;:
                    value = true;
                    break;
                case &#x27;false&#x27;:
                    value = false;
                    break;
            }

            // tls is nested object
            if (key.indexOf(&#x27;tls.&#x27;) === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf(&#x27;.&#x27;) &#x3e;= 0) {
                // ignore nested properties besides tls
                return;
            }

            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });

    return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
    
    <h2>
        <a href="#apidoc.element.nodemailer.shared.resolveContent" id="apidoc.element.nodemailer.shared.resolveContent">
        function <span class="apidocSignatureSpan">nodemailer.shared.</span>resolveContent
        <span class="apidocSignatureSpan">(data, key, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(data, key, callback) =&#x3e; {
    let promise;

    if (!callback &#x26;&#x26; typeof Promise === &#x27;function&#x27;) {
        promise = new Promise((resolve, reject) =&#x3e; {
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }

    let content = data &#x26;&#x26; data[key] &#x26;&#x26; data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === &#x27;object&#x27; &#x26;&#x26; data[key].encoding || &#x27;utf8&#x27;)
        .toString()
        .toLowerCase()
        .replace(/[-_\s]/g, &#x27;&#x27;);

    if (!content) {
        return callback(null, content);
    }

    if (typeof content === &#x27;object&#x27;) {
        if (typeof content.pipe === &#x27;function&#x27;) {
            return resolveStream(content, (err, value) =&#x3e; {
                if (err) {
                    return callback(err);
                }
                // we can&#x27;t stream twice the same content, so we need
                // to replace the stream object with the streaming result
                data[key] = value;
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = fetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            let parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
            if (!parts) {
                return callback(null, new Buffer(0));
            }
            return callback(null, /\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], &#x27;base64&#x27;) : new Buffer(decodeURIComponent(p\
arts[2])));
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }

    if (typeof data[key].content === &#x27;string&#x27; &#x26;&#x26; ![&#x27;utf8&#x27;, &#x27;usascii&#x27;, &#x27;ascii&#x27;].includes(encoding)) {
        content = new Buffer(data[key].content, encoding);
    }

    // default action, return as is
    setImmediate(() =&#x3e; callback(null, content));

    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
    
    
</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
